<!DOCTYPE html>
<html lang="ko">
<head>
    <meta charset="UTF-8">
    <title>Minimalist Gallery</title>
    <style>
        /* í…ìŠ¤íŠ¸ ìš”ì†Œ ì œê±° ë° ìŠ¤í¬ë¡¤ ë°©ì§€ */
        body { margin: 0; overflow: hidden; background-color: #ffffff; }
    </style>
</head>
<body>
    <script src="https://cdnjs.cloudflare.com/ajax/libs/three.js/r128/three.min.js"></script>
    <script src="https://cdn.jsdelivr.net/npm/three@0.128.0/examples/js/controls/OrbitControls.js"></script>
    <script src="https://cdnjs.cloudflare.com/ajax/libs/gsap/3.9.1/gsap.min.js"></script>

    <script>
        // --- 1. ì”¬ ì„¤ì • (í™”ì´íŠ¸ ë¯¸ë‹ˆë©€ë¦¬ì¦˜) ---
        const scene = new THREE.Scene();
        scene.background = new THREE.Color(0xffffff); 
        scene.fog = new THREE.Fog(0xffffff, 2, 30); // ê¹Šì´ê°

        const camera = new THREE.PerspectiveCamera(60, window.innerWidth / window.innerHeight, 0.1, 100);
        camera.position.set(0, 1.6, 5); // ì´ˆê¸° ìœ„ì¹˜

        const renderer = new THREE.WebGLRenderer({ antialias: true, alpha: true });
        renderer.setSize(window.innerWidth, window.innerHeight);
        renderer.shadowMap.enabled = true;
        renderer.shadowMap.type = THREE.PCFSoftShadowMap; 
        document.body.appendChild(renderer.domElement);

        // --- 2. ì¡°ëª… ---
        const ambientLight = new THREE.AmbientLight(0xffffff, 0.9); 
        scene.add(ambientLight);

        const dirLight = new THREE.DirectionalLight(0xffffff, 0.3);
        dirLight.position.set(5, 10, 7);
        dirLight.castShadow = true;
        scene.add(dirLight);

        // --- 3. ê³µê°„ êµ¬ì„± ---
        // ë°”ë‹¥ ê·¸ë¦¬ë“œë§Œ ë‚¨ê²¨ ë¯¸ë‹ˆë©€í•¨ ê°•ì¡°
        const gridHelper = new THREE.GridHelper(100, 100, 0xcccccc, 0xeeeeee);
        scene.add(gridHelper);

        // ë°”ë‹¥ (ê·¸ë¦¼ììš© íˆ¬ëª… ë°”ë‹¥)
        const floorGeo = new THREE.PlaneGeometry(100, 100);
        const floorMat = new THREE.ShadowMaterial({ opacity: 0.05 }); 
        const floor = new THREE.Mesh(floorGeo, floorMat);
        floor.rotation.x = -Math.PI / 2;
        floor.receiveShadow = true;
        scene.add(floor);

        // --- 4. ê·¸ë¦¼ ìƒì„± ---
        const artworks = [];
        let activeArtwork = null; // í˜„ì¬ ë³´ê³  ìˆëŠ” ê·¸ë¦¼

        function createPainting(imageUrl, x, y, z, rotY) {
            const group = new THREE.Group();

            // í”„ë ˆì„ (ì•„ì£¼ ì–‡ì€ ê²€ì • ë¼ì¸)
            const frameGeo = new THREE.BoxGeometry(2.05, 3.05, 0.05);
            const frameMat = new THREE.MeshBasicMaterial({ color: 0x000000 });
            const frame = new THREE.Mesh(frameGeo, frameMat);
            group.add(frame);

            // ê·¸ë¦¼ (í‘ë°±ì²˜ë¦¬ëœ ì´ë¯¸ì§€)
            const textureLoader = new THREE.TextureLoader();
            const texture = textureLoader.load(imageUrl);
            const canvasGeo = new THREE.PlaneGeometry(2, 3);
            const canvasMat = new THREE.MeshBasicMaterial({ map: texture, side: THREE.FrontSide });
            const canvas = new THREE.Mesh(canvasGeo, canvasMat);
            canvas.position.z = 0.03; // í”„ë ˆì„ë³´ë‹¤ ì‚´ì§ ì•
            group.add(canvas);

            // ë°°ì¹˜
            group.position.set(x, y, z);
            group.rotation.y = rotY;

            // ê·¸ë¦¼ì
            frame.castShadow = true;

            // ì›ë˜ ìœ„ì¹˜ ì €ì¥
            group.userData = {
                originalPos: group.position.clone(),
                originalRot: group.rotation.clone(),
                id: Math.random() // ê³ ìœ  ID
            };

            scene.add(group);
            artworks.push(group);
        }

        // ì´ë¯¸ì§€ ìƒì„± (í‘ë°± í•„í„° ì ìš©ëœ URL)
        createPainting('https://picsum.photos/id/237/400/600?grayscale', -3, 1.8, 0, Math.PI / 2);
        createPainting('https://picsum.photos/id/26/400/600?grayscale', 0, 1.8, -4, 0);
        createPainting('https://picsum.photos/id/1003/400/600?grayscale', 3, 1.8, 0, -Math.PI / 2);


        // --- 5. ì»¨íŠ¸ë¡¤ ---
        const controls = new THREE.OrbitControls(camera, renderer.domElement);
        controls.enableDamping = true;
        controls.dampingFactor = 0.05;
        controls.minDistance = 2;
        controls.maxDistance = 10;
        // ë°”ë‹¥ ë°‘ìœ¼ë¡œ ì¹´ë©”ë¼ê°€ ë‚´ë ¤ê°€ì§€ ì•Šê²Œ ì œí•œ (ë°”ë‹¥ ëš«ë¦¼ ë°©ì§€ ë³´ì¡°)
        controls.maxPolarAngle = Math.PI / 2 - 0.05; 


        // --- 6. ì¸í„°ë™ì…˜ ë¡œì§ (ìˆ˜ì •ë¨) ---
        const raycaster = new THREE.Raycaster();
        const mouse = new THREE.Vector2();

        window.addEventListener('click', (e) => {
            mouse.x = (e.clientX / window.innerWidth) * 2 - 1;
            mouse.y = -(e.clientY / window.innerHeight) * 2 + 1;

            raycaster.setFromCamera(mouse, camera);
            const intersects = raycaster.intersectObjects(artworks, true);

            if (intersects.length > 0) {
                // í´ë¦­ëœ ê·¸ë¦¼ ì°¾ê¸°
                let target = intersects[0].object;
                while(target.parent && target.parent.type !== 'Scene') {
                    target = target.parent;
                }

                // [ë¡œì§ ë³€ê²½]
                // 1. ì´ë¯¸ í™•ëŒ€ëœ ê·¸ë¦¼ì„ ë˜ í´ë¦­í–ˆë‹¤ë©´? -> ë„£ê¸° (Toggle OFF)
                if (activeArtwork === target) {
                    returnArtwork(target);
                } 
                // 2. ë‹¤ë¥¸ ê·¸ë¦¼ì„ í´ë¦­í–ˆë‹¤ë©´? -> ê¸°ì¡´ ê²ƒ ë„£ê³ , ìƒˆ ê²ƒ ëº´ê¸°
                else {
                    if (activeArtwork) returnArtwork(activeArtwork);
                    viewArtwork(target);
                }
            } else {
                // ë°°ê²½ í´ë¦­ ì‹œ -> ê¸°ì¡´ ê²ƒ ë„£ê¸°
                if (activeArtwork) returnArtwork(activeArtwork);
            }
        });

        // ğŸŸ¢ ê·¸ë¦¼ í™•ëŒ€ (í™”ë©´ ì •ë©´ ê³ ì • ë°©ì‹)
        function viewArtwork(group) {
            activeArtwork = group;
            controls.enabled = false; // ì‹œì  ì ê¸ˆ

            // [ê³„ì‚° ìˆ˜ì •] ì¹´ë©”ë¼ ìœ„ì¹˜ ê¸°ì¤€ + ì¹´ë©”ë¼ê°€ ë³´ëŠ” ë°©í–¥ìœ¼ë¡œ 2.5m ì•
            // ì´ ë°©ì‹ì€ ì¹´ë©”ë¼ê°€ ë°”ë‹¥ì„ ë³´ë“  ìœ„ë¥¼ ë³´ë“  ìƒê´€ì—†ì´ "ë‚´ ëˆˆì•"ì— ë‘¡ë‹ˆë‹¤.
            const direction = new THREE.Vector3();
            camera.getWorldDirection(direction); // ì¹´ë©”ë¼ê°€ ë³´ëŠ” ë°©í–¥ ë²¡í„° ê°€ì ¸ì˜¤ê¸°
            
            // ëª©í‘œ ìœ„ì¹˜ = ì¹´ë©”ë¼ìœ„ì¹˜ + (ë°©í–¥ * ê±°ë¦¬)
            const targetPos = camera.position.clone().add(direction.multiplyScalar(2.5));

            // 1. ìœ„ì¹˜ ì´ë™
            gsap.to(group.position, {
                x: targetPos.x,
                y: targetPos.y,
                z: targetPos.z,
                duration: 1.0,
                ease: "power2.out"
            });

            // 2. íšŒì „ ì´ë™ (ì¹´ë©”ë¼ì™€ ë˜‘ê°™ì€ ê°ë„ë¡œ íšŒì „ì‹œì¼œ í‰ë©´ì²˜ëŸ¼ ë³´ì´ê²Œ í•¨)
            // Quaternionì„ ë°”ë¡œ ë³µì‚¬í•˜ëŠ” ê²ƒì´ ê°€ì¥ ì •í™•í•˜ê²Œ ì •ë©´ì„ ë´…ë‹ˆë‹¤.
            // GSAP ì• ë‹ˆë©”ì´ì…˜ì„ ìœ„í•´ Eulerë¡œ ë³€í™˜í•˜ì—¬ ì ìš©
            const targetRot = new THREE.Euler().setFromQuaternion(camera.quaternion);

            gsap.to(group.rotation, {
                x: targetRot.x,
                y: targetRot.y,
                z: targetRot.z,
                duration: 1.0,
                ease: "power2.out"
            });
        }

        // âšª ê·¸ë¦¼ ë³µê·€
        function returnArtwork(group) {
            if (!group) return;

            // ì›ë˜ ìœ„ì¹˜ë¡œ ë³µê·€
            gsap.to(group.position, {
                x: group.userData.originalPos.x,
                y: group.userData.originalPos.y,
                z: group.userData.originalPos.z,
                duration: 0.8,
                ease: "power2.inOut"
            });

            // ì›ë˜ íšŒì „ìœ¼ë¡œ ë³µê·€
            gsap.to(group.rotation, {
                x: group.userData.originalRot.x,
                y: group.userData.originalRot.y,
                z: group.userData.originalRot.z,
                duration: 0.8,
                ease: "power2.inOut",
                onComplete: () => {
                    if (activeArtwork === group) { // í˜„ì¬ í™œì„± ìƒíƒœì˜€ë˜ ê²ƒë§Œ í•´ì œ
                        activeArtwork = null;
                        controls.enabled = true; // ì‹œì  ì ê¸ˆ í•´ì œ
                    }
                }
            });
        }

        function animate() {
            requestAnimationFrame(animate);
            controls.update();
            renderer.render(scene, camera);
        }

        window.addEventListener('resize', () => {
            camera.aspect = window.innerWidth / window.innerHeight;
            camera.updateProjectionMatrix();
            renderer.setSize(window.innerWidth, window.innerHeight);
        });

        animate();
    </script>
</body>
</html>
